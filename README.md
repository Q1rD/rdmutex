# RDMutex

## RDMutex

`RDMutex` (Reader-Demoting Mutex) — это специализированный мьютекс, который автоматически преобразует конкурирующих писателей в читателей при наличии активной записи. В отличие от традиционных RW-мьютексов, где писатели блокируются до освобождения, RDMutex демотивирует дополнительных писателей до уровня читателей, позволяя им немедленно работать с актуальными данными после завершения текущей операции записи.

### Ключевые особенности
- **Единичный писатель**: В любой момент времени только один писатель может удерживать мьютекс. Если другой писатель пытается захватить мьютекс, он автоматически переводится в режим читателя.
- **Параллельные читатели**: Множественные читатели могут одновременно получать доступ к ресурсу, если нет активного писателя.
- **Безопасность конкуренции**: Использует атомарные операции (`sync/atomic`) и условные переменные (`sync.Cond`) для эффективной и безопасной синхронизации.
- **Обработка ошибок**: Предусмотрена проверка некорректных вызовов (например, попытка разблокировки незалоченного мьютекса) с возвратом ошибок.

### Когда использовать
`RDMutex` подходит для сценариев, где:
- Запись в общий ресурс происходит часто и есть вероятность конкуренции между писателями

### Примечание
`RDMutex` находится в стадии разработки и предназначен для экспериментального использования. Перед применением в продакшене рекомендуется тщательно протестировать его в ваших сценариях.

## Установка

```bash
go get github.com/Q1rD/rdmutex
```

## Пример использования

```go
package main

import (
	"fmt"
	"sync"
	"time"

	rdmutex "github.com/Q1rD/rdmutex/rdmutex"
)

// SharedResource представляет общий ресурс с счётчиком.
type SharedResource struct {
	count int
	mu    *rdmutex.RDMutex
}

func NewSharedResource() *SharedResource {
	return &SharedResource{
		count: 0,
		mu:    rdmutex.NewRDMutex(),
	}
}

// Update пытается увеличить счётчик как писатель. Если другой писатель активен,
// горутина становится читателем и выводит текущее значение.
func (sr *SharedResource) Update(id int) {
	if sr.mu.Lock() {
		// Захватили мьютекс как писатель
		fmt.Printf("Горутина %d: Захвачен как писатель, увеличиваем счётчик\n", id)
		sr.count++
		time.Sleep(500 * time.Millisecond) // Симуляция работы
		sr.mu.Unlock()
	} else {
		// Стали читателем из-за активного писателя
		fmt.Printf("Горутина %d: Стал читателем, ждём писателя\n", id)
		sr.mu.Wait()
		fmt.Printf("Горутина %d: Прочитано значение счётчика: %d\n", id, sr.count)
		if err := sr.mu.RUnlock(); err != nil {
			fmt.Printf("Горутина %d: Ошибка разблокировки: %v\n", id, err)
		}
	}
}

// Read читает текущее значение счётчика как читатель.
func (sr *SharedResource) Read(id int) {
	sr.mu.RLock()
	fmt.Printf("Горутина %d: Чтение, текущее значение счётчика: %d\n", id, sr.count)
	time.Sleep(50 * time.Millisecond) // Симуляция чтения
	if err := sr.mu.RUnlock(); err != nil {
		fmt.Printf("Горутина %d: Ошибка разблокировки: %v\n", id, err)
	}
}

func main() {
	sr := NewSharedResource()
	var wg sync.WaitGroup

	// Запускаем 1 писателя
	wg.Add(1)
	go func() {
		defer wg.Done()
		sr.Update(1)
	}()

	time.Sleep(50 * time.Millisecond)

	// Запускаем ещё 1 писателя
	wg.Add(1)
	go func() {
		defer wg.Done()
		sr.Update(1)
	}()

	// Запускаем 2 читателя
	for i := 1; i < 3; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			sr.Read(id)
		}(i)
	}

	// Ждём завершения всех горутин
	wg.Wait()
	fmt.Printf("Итоговое значение счётчика: %d\n", sr.count)
}
```

## Пример вывода
```
Горутина 1: Захвачен как писатель, увеличиваем счётчик
Горутина 2: Стал читателем, ждём писателя
Горутина 2: Прочитано значение счётчика: 1
Горутина 3: Чтение, текущее значение счётчика: 1
Горутина 4: Чтение, текущее значение счётчика: 1
Итоговое значение счётчика: 1
```
